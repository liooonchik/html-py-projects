<!DOCTYPE html>
<html lang="pl">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="UTF-8">
<meta name="keywords" content="projekty, Python, Java, Gra w życie, ekosystem, symulacje, programowanie, Vladyslav Dovhopiatyi">
<meta name="description" content="Symulacja ekosystemu w Pythonie — automatyczna aplikacja inspirowana grą w życie Conwaya, z organizmami o różnych typach (rośliny, roślinożercy, mięsożercy, wszystkożercy), które poruszają się, jedzą, rozmnażają i umierają. Projekt zawiera wizualizację za pomocą emoji i wykresy zmian populacji."> 
<meta name="author" content="Vladyslav Dovhopiatyi">
<title>Symulacja ekosystemu &mdash; gra w Pythonie bez udziału gracza</title>
<!-- <link rel="icon" type="image/svg+xml" href="favicon.svg"> -->
<link rel="icon" type="image/png" href="favicon.png">

<style>

* {box-sizing: border-box;} 

@keyframes colorchange {
0% {background-color: #ffffff;}
20% {background-color: #ccffcc;}
40% {background-color: #ffffff;}
60% {background-color: #ccffff;}
80% {background-color: #ffffff;}
100% {background-color: #ccccff;}
}

body {
margin-top: 80px;
animation: colorchange 60s infinite;
}

header {
position: fixed;
top:0; left:0; right:0;
z-index: 1000;
background-color: #0040ff;
padding: 10px;
display: flex;
justify-content: space-between;
max-height: 100px;
}

.szukaj-container {	
max-width: 250px;
margin: 10px auto
}

#google_search {
width: 200%;
padding: 10px 10px 10px 15px;
border: 1px solid black;
border-radius: 25px;
}

.autocomplete-item {
background-color: white;
border: 1px solid #d4d4d4;
cursor: pointer;
padding: 10px;
width: 200%;
}

.autocomplete-item:hover {
background-color: #e9e9e9;
}

.autocomplete-active {
background-color: #d4d4d4;
}

.nav1 {
position: fixed;
top: 70px;
left: 0;
width: 20%;
height: 100%; 
background-color: rgb(0, 162, 255);
padding: 20px;
}

.nav1 a {
display: block;
padding: 10px 20px;
text-decoration: none;
color: black;
}

.nav1 a:hover {
background-color: hsl(280, 100%, 70%)
}

.headers {
text-align:center;
margin-left: 25%;
width: 75%;
}

p {
text-align:center;
margin-left: 25%;
font-size: 120%;
line-height: 1.6;
}

@keyframes bounce {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(10px); }
}

.style_code {
background-color: #f2f2f2;
border-radius: 10px;
font-size: 14px;
line-height: 1.5;
border: 2px solid rgb(128, 128, 128);
margin-left: 25%;
padding: 10px;
display: block;
overflow-x: auto;
max-height: 250px;
overflow-y: hidden;
}

.style_code.expanded {
max-height: 700px;
overflow-y: auto;
}

.button_container {
text-align: center;
margin-left: 25%;
width: 75%;
}

a.button-link {
text-align:center;
border-radius: 25px;
background-color:#cc66ff;
color:white;
padding: 15px 25px;
text-decoration: none;
display: inline-block;
margin: 5px;
}
a.button-link:hover {
background-color: #d32f2f;
}

.square_container {
display: flex;
flex-wrap: wrap;
justify-content: center;
margin-left: 25%;
width: 75%;
gap: 20px;
margin-top: 30px;
}

.square {
background-color:#ffffff;
border-radius: 15px;
padding: 20px;
width: 100%;
box-shadow: 10px 10px 1px #ccccff;
transition: transform 0.5s;
display: flex;
align-items: center;
min-height: 200px; 
}

.square p {
text-align: left;
margin: 0;
line-height: 2;
}

@media (max-width: 768px) {

.szukaj-container {
max-width: 100%;
width: 250px;
margin: 10px auto;
}

#google_search {
width: 100%;
padding: 10px 15px;
border: 1px solid black;
border-radius: 25px;
box-sizing: border-box;
}

.nav1 {
width: 250px;
left: -260px;
transition: left 0.3s ease;
padding-top: 60px;
}

.nav1.active {
left: 0;
}

#toggleNav {
position: fixed;
top: 82px;
left: 0px;
z-index: 1100;
font-size: 20px;
background: #669999;
color: white;
border: 3px solid black;
padding: 8px 12px;
cursor: pointer;
display: block;
}

#toggleNav.hidden {
display: none;
}

header {
display: flex;
flex-wrap: wrap; 
align-items: center;
justify-content: space-between;
}

h1, p, .square_container, .button_container {
margin-left: 0;
width: 100%;
padding: 10px;
}

.headers {
text-align: center;
padding: 10px;
width: 100%;
}

p {
text-align: center;
padding: 10px;
font-size: 120%;
width: 100%;
}

.square {
padding: 10px;
font-size: 100%;
}

.style_code {
font-size: 12px;
padding: 10px;
margin: 0;
width: 100%;
}

.headers, p, .button_container {
padding: 10px;
margin-left: 0;
width: 100%;
}
  
.square, .headers, .style_code {
max-width: 900px;
margin: auto;
}

.square_container {
display: flex;
flex-wrap: wrap;
justify-content: center;
padding: 10px;
gap: 20px;
margin-left: 0;
width: 100%;
}
.square {
width: 100%;
}
}
</style>

</head>
<body>

<button id="toggleNav" class="hidden" aria-label="Menu">☰</button>

<header>

<a href="omnie.html">
<img src="favi.jpg" alt="Logo strony" width="50" height="50">
</a>

<div class="szukaj-container">
<input id="google_search" type="text" placeholder="Wyszukiwarka projektów" autocomplete="off" oninput="obsługa_wyszukiwarki()" aria-label="Wyszukiwarka projektów">
<div id="autocomplete-list" class="autocomplete-items" style="max-width: 250px; margin-top: 5px;"></div>
</div>

</header>

<nav class="nav1">
<a href="index.html">Python: co to?</a>
<a href="gra_w_zycie.html">Gra w życie</a>
<a href="symulacja_ekosystemy.html">Symulacja ekosystemy</a>
<a href="omnie.html">O mnie</a>

</nav>

<main>

<script src="wyszukiwarka_script.js"></script>

<h1 class="headers">Symulacja ekosystemu</h1>

<div class="square_container">
<div class="square">

<p>Symulacja ekosystemu to zautomatyzowana gra, która modeluje interakcje między różnymi typami organizmów: roślinami, roślinożercami, mięsożercami i wszystkożercami. Projekt częściowo opiera się na wcześniejszej pracy &mdash; „Gra w życie” &mdash; i wykorzystuje niektóre metody, funkcje oraz zaimportowane moduły. Do wizualizacji symulacji używana jest biblioteka <b>PyQt5</b>, a do tworzenia wykresów i diagramów &mdash; <b>matplotlib.</b></p>

</div>
</div>

<div class="square_container">
<div class="square">

<p>Gra działa całkowicie autonomicznie i nie wymaga interwencji użytkownika. Każdy typ organizmu posiada własne zasady istnienia: rozmnażania, starzenia się, odżywiania oraz śmierci. W przypadku całkowitego wyginięcia danego typu organizmu, zostaje on automatycznie odtworzony w celu zachowania bioróżnorodności i równowagi ekosystemu.</p>

</div>
</div>

<p style="color:#cc0000;"><strong>&#128187; Pełny kod znajdziesz na końcu tej strony. &#128187; </strong></p>

<p style="padding-top:0px; font-size: 250%; color:#cc0000; animation: bounce 1.5s infinite;"><b>&#x2B07; &#x2B07; &#x2B07;</b></p>

<div class="button_container">
<a href="#projekt_kon_sym" class="button-link"><b>Symulacja ekosystemy</b></a>
</div>
<br>
<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Imports</h2>


<pre><code class="style_code">
import sys
import random
import csv
import matplotlib.pyplot as plt
from PyQt5.QtWidgets import QApplication, QWidget, QGridLayout, QLabel
from PyQt5.QtCore import Qt, QTimer
</code></pre>

<div class="square_container">
<div class="square">

<p><b style="color:#e65c00">import</b> <b>sys</b> &mdash; moduł umożliwiający pracę z funkcjami systemowymi.<br>

<b style="color:#e65c00">import</b> <b>random</b> &mdash; moduł do generowania losowych liczb i losowego wyboru elementów.<br>

<b style="color:#e65c00">import</b> <b>csv</b> &mdash; Importuje standardowy moduł Pythona <b>csv</b>, który umożliwia odczyt i zapis danych w formacie często używanym do przechowywania tabelarycznych danych.<br>

<b style="color:#e65c00">import</b> <b>matplotlib.pyplot as plt</b> &mdash; Importuje moduł <b>pyplot</b> z biblioteki <b>matplotlib</b> i nadaje mu alias <b>plt</b>. Umożliwia tworzenie wykresów, diagramów i wizualizacji danych.

</div>
</div>

<div class="square_container">
<div class="square">

<p><b style="color:#e65c00">from</b> <b>PyQt5.QtWidgets</b> <b style="color:#e65c00">import</b> <b>QApplication, QWidget, QGridLayout, QLabel</b> &mdash; Ten wiersz importuje klasy z biblioteki PyQt5, które służą do tworzenia graficznego interfejsu użytkownika: <b>QApplication</b> zarządza aplikacją, <b>QWidget</b> reprezentuje główne okno lub komponenty, <b>QGridLayout</b> umożliwia siatkowe rozmieszczanie elementów, a <b>QLabel</b> służy do wyświetlania tekstu lub obrazów.<br>

<b style="color:#e65c00">from</b> <b>PyQt5.QtCore</b> <b style="color:#e65c00">import</b> <b>Qt, QTimer</b> &mdash; importuje klasy z PyQt5 do tworzenia GUI: okna, układu, grafiki i timerów.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Rozmiar okna</h2>

<pre><code class="style_code">
rozmiar_okna = 30 #Ustawiamy rozmiar okna (będzie użyty dalej w kodzie)
</code></pre>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Organizm &mdash; główny klas(rodzic)</h2>

<pre><code class="style_code">
class Organizm:
    def __init__(self):
        self.wiek = 0
        self.energia = 0

    def symbol(self):
        return '⬜'

    def generacja(self, x, y, Plansza):
        self.wiek += 1

    def znalezc_sasiadow(self, x, y, Plansza):
        sasiedzi = []
        for delta_x in range(-1, 2):
            for delta_y in range(-1, 2):
                if (delta_x == 0 and delta_y == 0):
                    continue
                nowy_x = x + delta_x
                nowy_y = y + delta_y
                if 0 &lt;= nowy_x &lt; rozmiar_okna and 0 &lt;= nowy_y &lt; rozmiar_okna:
                    sasiedzi.append((nowy_x, nowy_y, Plansza[nowy_x][nowy_y]))
        random.shuffle(sasiedzi)
        return sasiedzi
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Ten kluczowy klas rodzicielski jest bazą dla innych klas, takich jak Pustka, Roslina, Roślinożerca, Mięsożerca oraz Wszystkożerca. Takie podejście zapewnia wygodne i elastyczne dziedziczenie właściwości i metod. Początkowo każdy organizm ma wiek i energię ustawione na zero, co umożliwia późniejsze łatwe modyfikacje tych wartości. <br>Metoda <code><b>symbol(self)</b></code> zwraca symbol białego kwadratu (&#11036;), który reprezentuje niezajętą przestrzeń na planszy.<br>Metoda <code><b>generacja(self, x, y, Plansza)</b></code> odpowiada za inkrementację wieku organizmu o jeden w każdej generacji symulacji.<br>Metoda <code><b>znalezc_sasiadow(self, x, y, Plansza)</b></code> przeszukuje sąsiednie pola wokół pozycji (x, y), szukając sąsiadów w promieniu 1 pola w każdym kierunku. Znalezieni sąsiedzi są losowo tasowani, co umożliwia symulowanie losowego ruchu organizmów lub ucieczki od nich.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Pustka &mdash; reprezentuje puste pole na planszy</h2>

<pre><code class="style_code">
class Pustka(Organizm):
    def symbol(self):
        return "⬜"
</code></pre>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Pustka</b></code> dziedziczy po klasie <code><b>Organizm</b></code> i reprezentuje niezajętą przestrzeń na planszy ekosystemu. Jej głównym zadaniem jest zwracanie odpowiedniego symbolu — pustego białego kwadratu (&#11036;) &mdash; co umożliwia łatwe wizualne rozróżnienie wolnych miejsc od tych zajętych przez inne organizmy.<br>Klasa ta nie zawiera dodatkowej logiki ani metod, ponieważ nie bierze udziału w procesach takich jak rozmnażanie, ruch czy zdobywanie energii. Służy jedynie jako "tło" lub "przestrzeń" w symulacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Roślin</h2>

<pre><code class="style_code">
class Roslina(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 1
    def symbol(self):
        return "🥕"

    def generacja(self, x, y, Plansza):
        self.wiek += 1
        if self.energia &lt; 10:
            self.energia += 1

        liczba_roslin = 0
        for wiersz in Plansza:
            for organizm in wiersz:
                if type(organizm) &#61;&#61; Roslina:
                    liczba_roslin +&#61; 1

        max_roslin = (rozmiar_okna * rozmiar_okna) // 2

        if self.wiek >= 4 and liczba_roslin &lt; max_roslin:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) &#61;&#61; Pustka:
                    Plansza[nowy_x][nowy_y] = Roslina()
                    break
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Roslina</b></code> dziedziczy po <code><b>Organizm</b></code> i reprezentuje rośliny w ekosystemie. W konstruktorze nadawana jest początkowa energia <code>1</code>, co odzwierciedla zdolność rośliny do powolnego gromadzenia energii.<br> Metoda <code><b>symbol()</b></code> zwraca ikonę 🥕, która służy do wizualnego przedstawienia rośliny na planszy.<br>W metodzie <code><b>generacja()</b></code> każda roślina starzeje się (wiek +1) oraz powoli zwiększa swoją energię, maksymalnie do 10. Jeśli osiągnie wiek co najmniej 4 i całkowita liczba roślin w ekosystemie jest mniejsza niż połowa pól planszy, roślina próbuje rozmnożyć się na sąsiednie wolne pole. Dzięki temu systemowi rośliny mogą się rozprzestrzeniać, ale ich liczba pozostaje pod kontrolą, co zapobiega zdominowaniu całej planszy.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Roślinożerca</h2>

<pre><code class="style_code">
class Roslinozerca(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 8
    def symbol(self):
        return "🐇"

    def generacja(self, x, y, Plansza):
        self.wiek += 1
        if self.energia &lt;&#61; 0:           #nie umiera kiedy niema energii, jeśli nie ma energii i pojawi się roślina, można ją zjeść
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) &#61;&#61; Roslina:
                    self.energia += 2
                    Plansza[nowy_x][nowy_y] = Pustka()
                    break
            if self.wiek > 15:
                Plansza[x][y] = Pustka()
                return
        self.energia -= 1
        ruch = False

        for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
            if type(sasiad) == Roslina:
                self.energia += 2
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break

        if not ruch:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Pustka:
                    self.energia -= 1
                    Plansza[nowy_x][nowy_y] = self
                    Plansza[x][y] = Pustka()
                    break
        if self.wiek >= 4 and self.energia >= 4:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Roslinozerca and sasiad.wiek >= 4 and sasiad.energia >= 4:
                    for pustka_x, pustka_y, pustka in self.znalezc_sasiadow(x, y, Plansza):
                        if type(pustka) == Pustka:
                            Plansza[pustka_x][pustka_y] = Roslinozerca()
                            break
                    break
        if self.wiek > 15:
            Plansza[x][y] = Pustka() #umiera, gdy osiąga wiek 15 lat

</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Roslinozerca</b></code> reprezentuje zwierzę roślinożerne w ekosystemie, np. królika 🐇. Dziedziczy po klasie <code><b>Organizm</b></code> i zaczyna z energią równą 8.<br>Organizm ten staje się coraz starszy i z każdą generacją traci energię. Gdy energia spada do zera, roślinożerca nadal próbuje przetrwać — jeśli w sąsiedztwie znajdzie roślinę, może ją zjeść i odzyskać energię. Jeśli jednak jest już stary (powyżej 15 cykli), umiera.<br>W przypadku znalezienia rośliny, przemieszcza się w jej miejsce, zwiększając energię. Gdy nie znajdzie jedzenia, próbuje przesunąć się na puste pole, tracąc dodatkową energię.<br>Jeśli roślinożerca osiągnął wiek co najmniej 4 cykle i posiada wystarczającą energię, może się rozmnażać, jeśli w pobliżu znajdzie się inny roślinożerca spełniający te same warunki oraz dostępne jest puste pole.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Mięsożerca</h2>

<pre><code class="style_code">
class Miesozerca(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 12
    def symbol(self):
        return "🐺"

    def generacja(self, x, y, Plansza):
        self.wiek += 1

        if self.energia &lt;&#61; 0:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) &#61;&#61; Roslinozerca:
                    self.energia += 9
                    Plansza[nowy_x][nowy_y] = Pustka()
                    break
            if self.wiek > 25:
                Plansza[x][y] = Pustka()
                return
        self.energia -= 2
        ruch = False

        for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
            if type(sasiad) == Roslinozerca:
                self.energia += 9
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break

        if not ruch:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Pustka:
                    self.energia -= 2
                    Plansza[nowy_x][nowy_y] = self
                    Plansza[x][y] = Pustka()
                    break
        if self.wiek >= 5 and self.energia >= 10:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Miesozerca and sasiad.wiek >= 5 and sasiad.energia >= 10:
                    for pustka_x, pustka_y, pustka in self.znalezc_sasiadow(x, y, Plansza):
                        if type(pustka) == Pustka:
                            Plansza[pustka_x][pustka_y] = Miesozerca()
                            break
        if self.wiek > 25:
            Plansza[x][y] = Pustka()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Miesozerca</b></code> reprezentuje drapieżnika w ekosystemie, na przykład wilka 🐺. Dziedziczy po klasie <code><b>Organizm</b></code> i startuje z energią 12 jednostek.<br>W każdej generacji zwiększa się wiek organizmu, a energia spada o 2 jednostki. Jeśli energia spadnie do zera, mięsożerca jeszcze próbuje zjeść pobliskiego roślinożercę, aby przetrwać. Gdy nie znajdzie pożywienia i osiągnie wiek powyżej 25, umiera.<br>Mięsożerca aktywnie szuka w otoczeniu roślinożerców, aby je zjeść i zdobyć energię. Jeśli nie znajdzie ofiary, próbuje przemieścić się na wolne pole, ale traci przy tym kolejne 2 jednostki energii.<br>Rozmnażanie jest możliwe, gdy organizm osiągnie wiek co najmniej 5 i ma energię co najmniej 10. Wtedy, jeśli w pobliżu znajduje się inny mięsożerca spełniający te warunki oraz dostępne jest puste pole, tworzony jest nowy osobnik.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Wszystkożerca</h2>

<pre><code class="style_code">
class Wszystkozerca(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 10
    def symbol(self):
        return "🐻"

    def generacja(self, x, y, Plansza):
        self.wiek += 1

        if self.energia &lt;&#61; 0:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Roslina:
                    self.energia += 3
                    Plansza[nowy_x][nowy_y] = Pustka()
                elif type(sasiad) &#61;&#61; Miesozerca:
                    self.energia += 7
                    Plansza[nowy_x][nowy_y] = Pustka()
                    break
            if self.wiek > 30:
                Plansza[x][y] = Pustka()
                return
        self.energia -= 1
        ruch = False

        for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
            if type(sasiad) == Roslina:
                self.energia += 3
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break
            elif type(sasiad) == Miesozerca:
                self.energia += 7
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break

        if not ruch:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Pustka:
                    self.energia -= 1
                    Plansza[nowy_x][nowy_y] = self
                    Plansza[x][y] = Pustka()
                    break
        if self.wiek >= 5 and self.energia >= 8:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Wszystkozerca and sasiad.wiek >= 5 and sasiad.energia >= 8:
                    for pustka_x, pustka_y, pustka in self.znalezc_sasiadow(x, y, Plansza):
                        if type(pustka) == Pustka:
                            Plansza[pustka_x][pustka_y] = Wszystkozerca()
                            break
        if self.wiek > 30:
            Plansza[x][y] = Pustka()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Wszystkozerca</b></code> reprezentuje wszystkożernego organizma, np. niedźwiedzia 🐻. Jest bardziej elastyczny niż inne organizmy — może jeść zarówno rośliny (🥕), jak i mięsożerców (🐺).<br>W każdej generacji wiek zwiększa się o 1, a energia spada o 1. Jeśli energia spadnie do zera, organizm próbuje znaleźć pożywienie — zjadając roślinę (+3 energii) lub mięsożercę (+7 energii). Gdy nie przeżyje i przekroczy wiek 30, umiera.<br>Wszystkożerca szuka pożywienia w sąsiedztwie, zaczynając od roślin i mięsożerców. Jeśli znajdzie jedzenie, przemieszcza się tam i regeneruje energię. W przeciwnym razie próbuje przemieścić się na wolne pole, tracąc kolejną jednostkę energii.<br>Rozmnaża się, gdy osiąga wiek ≥5 i energię ≥8, pod warunkiem, że w sąsiedztwie znajduje się inny dojrzały wszystkożerca. Wtedy, jeśli dostępne jest pole Pustki, powstaje nowy osobnik.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers"><mark>FabrykaKomorek</mark></h2>

<pre><code class="style_code">
class FabrykaKomorek:
    @staticmethod
    def utworz_komorke(type):
        if type == "Roslina":
            return  Roslina()
        elif type == "Roslinozerca":
            return  Roslinozerca()
        elif type == "Miesozerca":
            return Miesozerca()
        elif type == "Wszystkozerca":
            return Wszystkozerca()
        else:
            return Pustka()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><code><b>FabrykaKomorek</b></code> to klasa pomocnicza, która pełni rolę <b>fabryki statycznej</b> — wzorca projektowego służącego do tworzenia obiektów różnych klas potomnych bez potrzeby ręcznego wywoływania każdego konstruktora.<br>Główna metoda <code><b>utworz_komorke(type)</b></code> działa jako <b>statyczna metoda</b> (oznaczona jako <code><b>@staticmethod</b></code>), co oznacza, że można jej używać bez tworzenia instancji klasy <code><b>FabrykaKomorek</b></code>.<br>Metoda przyjmuje tekstowy parametr <code><b>type</b></code> i — w zależności od jego wartości — tworzy i zwraca odpowiedni obiekt.<br>Dzięki temu kod w innych częściach programu może dynamicznie tworzyć organizmy na podstawie np. danych wejściowych, bez potrzeby znajomości szczegółów konstruktora danego organizmu. To zwiększa modularność i upraszcza zarządzanie typami komórek w symulacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Obserwator</h2>

<pre><code class="style_code">
class Obserwator:
    def aktualizuj(self, plansza):
        pass
</code></pre>

<div class="square_container">
<div class="square">

<p><code><b>Obserwator</b></code> to abstrakcyjna (bazowa) klasa, która pełni rolę interfejsu w architekturze opartej na wzorcu <b>Obserwator</b><br>Zawiera metodę <code><b>aktualizuj(self, plansza)</b></code>, która na tym etapie nie wykonuje żadnych działań (<code>pass</code>), ale została zdefiniowana, aby mogła być nadpisywana przez klasy potomne.<br>Klasy dziedziczące po <code><b>Obserwator</b></code> implementują własną wersję metody <code><b>aktualizuj()</b></code>, która pozwala reagować na zmiany stanu planszy, np. odświeżając widok graficzny, zapisując dane lub analizując ekosystem.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">GUI</h2>

<p style=" background-color: #ffff00;">GUI &mdash; to Graphical User Interface, czyli po polsku &mdash; graficzny interfejs użytkownika</p>

<pre><code class="style_code">
class GUIWidok(Obserwator):
    def __init__(self):
        self.app = QApplication(sys.argv)
        self.window = QWidget()
        self.layout = QGridLayout(self.window)
        self.generacja_label = QLabel("Generacja: 0", self.window)
        self.generacja_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.generacja_label, 0, 0, 1, rozmiar_okna)
        self.labels = [[QLabel("⬜") for _ in range(rozmiar_okna)] for _ in range(rozmiar_okna)]
        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                self.layout.addWidget(self.labels[y][x], y + 1, x)
        self.window.setLayout(self.layout)
        self.window.setWindowTitle("Ekosystem")
        self.window.show()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<table style="width: 100%; border-collapse: collapse;" border="3" cellpadding="10">
<caption style="font-size: 150%; margin-bottom: 10px;"><b>GUIWidok</b></caption>
<tr style="background-color: #ff0000; color: white;">
  <th>Kod</th>
  <th>Za co odpowiada</th>
</tr>
<tr>
  <td><code>self.app = QApplication(sys.argv)</code></td>
  <td>Tworzy główną aplikację PyQt5</td>
</tr>
<tr>
  <td><code>self.window = QWidget()</code></td>
  <td>Tworzy główne okno aplikacji</td>
</tr>
<tr>
  <td><code>self.layout = QGridLayout(self.window)</code></td>
  <td>Układ siatki — rozkłada elementy w siatce (komórki planszy)</td>
</tr>
<tr>
  <td><code>self.generacja_label = QLabel("Generacja: 0", self.window)</code></td>
  <td>Wyświetla numer aktualnej generacji</td>
</tr>
<tr>
  <td><code>self.generacja_label.setAlignment(Qt.AlignCenter)</code></td>
  <td>Wyśrodkowuje tekst z numerem generacji</td>
</tr>
<tr>
  <td><code>self.layout.addWidget(self.generacja_label, 0, 0, 1, rozmiar_okna)</code></td>
  <td>Umieszcza etykietę generacji nad całą planszą</td>
</tr>
<tr>
  <td><code>self.labels = [[QLabel("⬜") for _ in range(rozmiar_okna)] for _ in range(rozmiar_okna)]</code></td>
  <td>Tworzy dwuwymiarową listę etykiet reprezentujących komórki planszy</td>
</tr>
<tr>
  <td><code>self.layout.addWidget(self.labels[y][x], y + 1, x)</code></td>
  <td>Dodaje etykiety komórek do siatki poniżej etykiety generacji</td>
</tr>
<tr>
  <td><code>self.window.setLayout(self.layout)</code></td>
  <td>Ustawia layout jako główny układ okna</td>
</tr>
<tr>
  <td><code>self.window.setWindowTitle("Ekosystem")</code></td>
  <td>Ustawia tytuł okna</td>
</tr>
<tr>
  <td><code>self.window.show()</code></td>
  <td>Wyświetla okno aplikacji</td>
</tr>
</table>

</div>
</div>

<h2 class="headers">Aktualizacja GUI</h2>

<pre><code class="style_code">
    def aktualizuj(self, plansza, numer_generacji = 0):
        self.generacja_label.setText(f"Generacja: {numer_generacji}")
        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                self.labels[y][x].setText(plansza[y][x].symbol())
</code></pre>

<div class="square_container">
<div class="square">

<p>Metoda <code><b>aktualizuj</b></code> odpowiada za odświeżenie interfejsu graficznego (GUI) po każdej generacji symulacji. Najpierw aktualizuje etykietę z numerem pokolenia (<code><b>generacja_label</b></code>), wyświetlając aktualną liczbę generacji. Następnie przechodzi przez wszystkie komórki planszy w dwóch pętlach i pobiera z każdej z nich obiekt organizmu. Dla każdego organizmu wywoływana jest metoda <code><b>symbol()</b></code>, która zwraca graficzny znak (np. 🥕, 🐇, 🐺), 
a następnie ten znak jest wyświetlany w odpowiednim polu siatki GUI (<code><b>QLabel</b></code>). W ten sposób stan planszy w modelu jest na bieżąco odwzorowywany wizualnie w aplikacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Inicjalizacja klasy Symulacja</h2>

<pre><code class="style_code">
class Symulacja:
    def __init__(self, plansza, widok):
        self.plansza = plansza
        self.widok = widok
        self.generacja = 0
        self.startowe_ilosci = {
            "Roslina": 1,
            "Roslinozerca": 20,
            "Miesozerca": 10,
            "Wszystkozerca": 3
        }

        self.csv_file_path = 'dane.csv'
        with open(self.csv_file_path, 'w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(["Generacja", "Roslina", "Roslinozerca", "Miesozerca", "Wszystkozerca"])

        self.timer = None
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Konstruktor klasy <code><b>Symulacja</b></code> odpowiada za przygotowanie wszystkich niezbędnych elementów do rozpoczęcia symulacji ekosystemu.<br><code><b>self.plansza</b></code> &mdash; odniesienie do dwuwymiarowej tablicy zawierającej organizmy w świecie symulacji. <code><b>self.widok</b></code> &mdash; obiekt GUI (np. <code>GUIWidok</code>), odpowiedzialny za graficzne przedstawienie planszy. <code><b>self.generacja</b></code> &mdash; licznik pokoleń (etapów symulacji), początkowo ustawiony na zero. <code><b>self.startowe_ilosci</b></code> &mdash; słownik definiujący ile osobników każdego typu ma być dodawane, jeśli któryś z nich zniknie całkowicie z planszy (np. 20 roślinożerców, 10 mięsożerców itd.). <code><b>self.csv_file_path</b></code> &mdash; ścieżka do pliku CSV, gdzie będą zapisywane dane statystyczne każdej generacji (liczebność każdego typu organizmu). Następnie tworzony jest nowy plik <code><b>dane.csv</b></code> i zapisywany jest nagłówek kolumn, aby móc później łatwo dodawać dane i generować wykresy. Zmienna <code><b>self.timer</b></code> jest domyślnie ustawiona na <code>None</code> i będzie używana do kontrolowania, kiedy zatrzymać symulację (np. po 300 generacjach).</p>

</div>
</div>

<h2 class="headers">Ustawianie timera</h2>

<pre><code class="style_code">
def czas_trwania(self, timer):
    self.timer = timer
    #Prosta metoda pomocnicza przypisująca zewnętrzny timer do obiektu klasy, który może być później użyty do zatrzymania animacji po 300 generacjach.
</code></pre>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Aktualizacja symulacji</h2>

<pre><code class="style_code">
    def aktualizuj(self):
        if self.generacja >= 300:
            if self.timer:
                self.timer.stop()
            print("Symulacja zakończona po 300 generacjach")
            return

        kierunek = [(x, y) for y in range(rozmiar_okna) for x in range(rozmiar_okna)]
        random.shuffle(kierunek)
        for x, y in kierunek:
            self.plansza[y][x].generacja(y, x, self.plansza)
        self.generacja += 1
        self.widok.aktualizuj(self.plansza, self.generacja)
        self.dodaj_brakujace_klasy()

        ilosc_roslin = 0
        ilosc_roslinozercow = 0
        ilosc_miesozercow = 0
        ilosc_wszystkozercow = 0

        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                organizm = self.plansza[y][x]
                if type(organizm) == Roslina:
                    ilosc_roslin += 1
                if type(organizm) == Roslinozerca:
                    ilosc_roslinozercow += 1
                if type(organizm) == Miesozerca:
                    ilosc_miesozercow += 1
                if type(organizm) == Wszystkozerca:
                    ilosc_wszystkozercow += 1
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Kontrola zakończenia symulacji:</b> Jeśli liczba generacji osiągnęła 300, zatrzymujemy timer i wyświetlamy komunikat o zakończeniu symulacji. <b>Losowa kolejność przetwarzania planszy:</b> Tworzymy listę wszystkich współrzędnych planszy, tasujemy ją, aby symulacja była bardziej realistyczna i nieprzewidywalna. <b>Wywołanie metody generacja dla każdego organizmu:</b> Dla każdej pozycji na planszy wywołujemy metodę <code><b>generacja</b></code>, która odpowiada za aktualizację stanu organizmu. <b>Zwiększenie numeru generacji i aktualizacja widoku:</b> Po przetworzeniu całej planszy zwiększamy licznik generacji i aktualizujemy GUI za pomocą metody <code><b>aktualizuj</b></code> widoku. <b>Dodanie brakujących klas organizmów:</b> Jeśli jakieś typy organizmów zniknęły z planszy, metoda <code><b>dodaj_brakujace_klasy</b></code> wprowadzi ich nowe instancje na wolne pola. <b>Zliczanie organizmów na planszy:</b> Iterujemy po całej planszy i zliczamy ile jest instancji każdego typu organizmu (<b><code>Roslina</code>, <code>Roslinozerca</code>, <code>Miesozerca</code>, <code>Wszystkozerca</code></b>).</p>

</div>
</div>

<h2 class="headers">plik CSV</h2>

<pre><code class="style_code">
        with open(self.csv_file_path, 'a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([self.generacja, ilosc_roslin, ilosc_roslinozercow, ilosc_miesozercow, ilosc_wszystkozercow])

        generacje = []
        rosliny = []
        roslinozercy = []
        miesozercy = []
        wszystkozercy = []

        with open(self.csv_file_path, mode= 'r') as file:
            czytacz = csv.DictReader(file)
            for wiersz in czytacz:
                generacje.append(int(wiersz['Generacja']))
                rosliny.append(int(wiersz['Roslina']))
                roslinozercy.append(int(wiersz['Roslinozerca']))
                miesozercy.append(int(wiersz['Miesozerca']))
                wszystkozercy.append(int(wiersz['Wszystkozerca']))
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Zapis danych do pliku CSV:</b> Otwieramy plik CSV w trybie dopisywania ('a') i zapisujemy aktualne wartości populacji oraz numer generacji w nowym wierszu. <b>Inicjalizacja list do przechowywania danych z pliku:</b> Tworzymy puste listy, które będą przechowywać kolejno numer generacji oraz liczby poszczególnych organizmów. <b>Odczyt danych z pliku CSV:</b> Otwieramy plik w trybie odczytu i używamy <code>csv.DictReader</code> do wygodnego czytania wierszy jako słowników. <b>Wypełnianie list danymi:</b> Dla każdego wiersza z pliku wyciągamy wartości dla kluczy: 'Generacja', 'Roslina', 'Roslinozerca', 'Miesozerca' oraz 'Wszystkozerca' i zamieniamy je na liczby całkowite, dodając do odpowiednich list.</p>

</div>
</div>

<h2 class="headers">Wykresy</h2>

<pre><code class="style_code">
        #wykres_liniowy:
        plt.plot(generacje, rosliny, label='Rosliny')
        plt.plot(generacje, roslinozercy, label='Roslinozercy')
        plt.plot(generacje, miesozercy, label='Miesozercy')
        plt.plot(generacje, wszystkozercy, label='Wszystkozercy')

        plt.title('Wykres liniowy populacji organizmów')
        plt.xlabel('Generacja')
        plt.ylabel('Liczba organizmow')
        plt.legend()
        plt.tight_layout()
        plt.savefig('wykres_liniowy.png', dpi=300)
        plt.close()

        #wykres_kołowy:
        wartosci = [ilosc_roslin, ilosc_roslinozercow, ilosc_miesozercow, ilosc_wszystkozercow]
        labels = ['Rosliny', 'Roslinozercy', 'Miesozercy', 'Wszystkozercy']

        plt.figure(figsize=(8, 6))
        plt.pie(wartosci, labels=labels, autopct='%1.1f%%', startangle=140)
        plt.axis('equal')
        plt.title('Wykres kołowy populacji organizmów')
        plt.tight_layout()
        plt.savefig('wykres_kolowy.png', dpi=300)
        plt.close()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Wykres liniowy:</b> Tworzymy wykres liniowy przedstawiający zmiany liczebności populacji różnych organizmów w kolejnych generacjach. Każda linia reprezentuje jedną klasę organizmów (Rosliny, Roslinozercy, Miesozercy, Wszystkozercy). Dodajemy tytuł, opisy osi (Generacja i Liczba organizmów), legendę oraz optymalizujemy układ elementów, aby dobrze się wyświetlały. Zapisujemy wykres jako plik PNG o wysokiej rozdzielczości (300 dpi), a następnie zamykamy wykres, by zwolnić zasoby.<br><b>Wykres kołowy:</b> Przygotowujemy listę wartości reprezentujących aktualną liczebność populacji każdej klasy organizmów oraz odpowiadające im etykiety. Ustawiamy rozmiar figury, tworzymy wykres kołowy z procentowym udziałem każdej populacji, ustawiamy równą skalę osi, tytuł i optymalny układ elementów. Zapisujemy wykres kołowy jako plik PNG i zamykamy go, aby zwolnić pamięć.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Uzupełnianie brakujących klas organizmów</h2>

<pre><code class="style_code">
    def dodaj_brakujace_klasy(self):
        klasy = {"Roslina": False, "Roslinozerca": False, "Miesozerca": False, "Wszystkozerca": False}

        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                objekt = self.plansza[y][x]
                if type(objekt) == Roslina:
                    klasy["Roslina"] = True
                elif type(objekt) == Roslinozerca:
                    klasy["Roslinozerca"] = True
                elif type(objekt) == Miesozerca:
                    klasy["Miesozerca"] = True
                elif type(objekt) == Wszystkozerca:
                    klasy["Wszystkozerca"] = True

        for klasa, obecny in klasy.items():
            if not obecny:
                wolne_pola = [(x, y) for y in range(rozmiar_okna) for x in range(rozmiar_okna)
                          if type(self.plansza[y][x]) == Pustka]
                ilosc_do_dodania = self.startowe_ilosci[klasa]
                for _ in range(ilosc_do_dodania):
                    if wolne_pola:
                        x, y = random.choice(wolne_pola)
                        wolne_pola.remove((x, y))
                        self.plansza[y][x] = FabrykaKomorek.utworz_komorke(klasa)
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Sprawdzanie obecności klas:</b> Na początku metoda tworzy słownik z nazwami klas organizmów, oznaczając każdą jako nieobecną (<code><b>False</b></code>). Następnie przegląda całe pole gry (<code><b>plansza</b></code>) i sprawdza, czy któryś z typów już się na nim znajduje — jeśli tak, zmienia jego status na <code><b>True</b></code>.<br><b>Dodawanie brakujących organizmów:</b> Dla każdej nieobecnej klasy tworzeń metoda wyszukuje wszystkie wolne pola (czyli te zawierające obiekt typu <code><b>Pustka</b></code>). Następnie na podstawie wstępnie zdefiniowanej liczby startowej (<code><b>startowe_ilosci</b></code>) losowo wybiera miejsca i umieszcza tam nowe obiekty danego typu przy pomocy metody <code><b>FabrykaKomorek.utworz_komorke</b></code>. Dzięki temu na planszy zawsze znajduje się przynajmniej jeden przedstawiciel każdej klasy organizmów.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Inicjalizacja planszy i losowanie pól</h2>

<pre><code class="style_code">
plansza = [[Pustka() for _ in range(rozmiar_okna)] for _ in range(rozmiar_okna)]
wolne_pola = [(x, y) for y in range(rozmiar_okna) for x in range(rozmiar_okna)]
random.shuffle(wolne_pola)
</code></pre>

<div class="square_container">
<div class="square">

<p> Na początku tworzymy dwuwymiarową listę <code>plansza</code>, która reprezentuje pole gry. Każde pole początkowo zawiera obiekt typu <code><b>Pustka()</b></code>, co oznacza, że jest puste i gotowe do zapełnienia organizmami.<br> Następnie generujemy listę wszystkich możliwych współrzędnych (x, y) dla całej planszy, które początkowo są wszystkie wolne. Dzięki temu mamy pełną kontrolę nad tym, gdzie można umieszczać nowe organizmy.<br> Za pomocą <code><b>random.shuffle()</b></code> mieszamy kolejność współrzędnych w liście <code>wolne_pola</code>. Pozwala to losowo przydzielać miejsca dla organizmów w dalszych etapach inicjalizacji, co sprawia, że rozkład startowy jest za każdym razem inny i nieprzewidywalny.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Dodawanie organizmów na planszę</h2>

<pre><code class="style_code">
def dodaj_obekty(type, liczba):
    for _ in range(liczba):
        if wolne_pola:
            x, y = random.choice(wolne_pola)
            wolne_pola.remove((x, y))
            plansza[y][x] = FabrykaKomorek.utworz_komorke(type)

dodaj_obekty("Roslina", 1)
dodaj_obekty("Roslinozerca",20)
dodaj_obekty("Miesozerca", 10)
dodaj_obekty("Wszystkozerca", 3)

</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">Pokaż więcej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Funkcja dodaj_obekty:</b> Definiujemy funkcję, która umożliwia dodawanie określonej liczby organizmów danego typu na losowe, wolne pola planszy. Dla każdego obiektu losujemy współrzędne z listy dostępnych pól <code>wolne_pola</code>, a następnie usuwamy to pole z listy, by uniknąć powtórzeń. Obiekt tworzony jest za pomocą fabryki komórek <code><mark>FabrykaKomorek.utworz_komorke(type)</mark></code>, co zapewnia elastyczność w tworzeniu różnych typów organizmów.<br> Po zdefiniowaniu funkcji wywołujemy ją, aby dodać różne klasy organizmów. Dzięki temu plansza zostaje zainicjalizowana startową populacją zgodnie z założeniami symulacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Inicjalizacja i uruchomienie symulacji graficznej</h2>

<pre><code class="style_code">
widok = GUIWidok()
symulacja = Symulacja(plansza, widok)
timer = QTimer()
symulacja.czas_trwania(timer)
timer.timeout.connect(lambda: symulacja.aktualizuj())
symulacja.aktualizuj()
timer.start(300)
widok.window.setGeometry(100, 100, 500, 500)
sys.exit(widok.app.exec_())
</code></pre>

<div class="square_container">
<div class="square">

<table style="width: 100%; border-collapse: collapse;" border="3" cellpadding="10">
<tr style="background-color: #ff0000; color: white;">
<th>Kod</th>
<th>Opis</th>
</tr>
<tr>
<td><code>widok = GUIWidok()</code></td>
<td>Tworzy instancję interfejsu graficznego, która odpowiada za wizualne przedstawienie planszy i jej aktualizacji.</td>
</tr>
<tr>
<td><code>symulacja = Symulacja(plansza, widok)</code></td>
<td>Inicjalizuje logikę symulacji, przekazując planszę oraz obiekt widoku GUI, aby mogły współpracować.</td>
</tr>
<tr>
<td><code>timer = QTimer()</code></td>
<td>Tworzy obiekt timera Qt, który umożliwia cykliczne wykonywanie akcji w określonych odstępach czasu.</td>
</tr>
<tr>
<td><code>symulacja.czas_trwania(timer)</code></td>
<td>Ustawia zależność pomiędzy timerem a symulacją — pozwala symulacji kontrolować czas jej działania (np. długość trwania).</td>
</tr>
<tr>
<td><code>timer.timeout.connect(lambda: symulacja.aktualizuj())</code></td>
<td>Łączy sygnał zakończenia odliczania timera z metodą aktualizacji symulacji, co pozwala na automatyczne odświeżanie stanu gry.</td>
</tr>
<tr>
<td><code>symulacja.aktualizuj()</code></td>
<td>Wywołuje natychmiastowe odświeżenie stanu planszy, tak aby pierwsze dane były widoczne przed uruchomieniem timera.</td>
</tr>
<tr>
<td><code>timer.start(300)</code></td>
<td>Uruchamia timer z interwałem 300 milisekund, co oznacza aktualizację symulacji co 0,3 sekundy.</td>
</tr>
<tr>
<td><code>widok.window.setGeometry(100, 100, 500, 500)</code></td>
<td>Ustawia pozycję oraz rozmiar głównego okna aplikacji GUI (500x500 pikseli, pozycja: x=100, y=100).</td>
</tr>
<tr>
<td><code>sys.exit(widok.app.exec_())</code></td>
<td>Uruchamia główną pętlę zdarzeń aplikacji PyQt i zamyka ją poprawnie po zakończeniu działania programu.</td>
</tr>
</table>

</div>
</div>

<script>
function toggleCode(button) {
const code = button.closest('.button_container').previousElementSibling.querySelector('.style_code');
code.classList.toggle('expanded');
button.textContent = code.classList.contains('expanded') ? 'Ukryj' : 'Pokaż więcej';
}
</script>

<h2 class="headers" id="projekt_kon_sym"><b>Pełny kod "Symulacja ekosystemy"</b></h2>

<div class="button_container">
<a href="symulacja_ekosystemy.py" target="_blank" rel="noopener noreferrer" class="button-link" download="symulacja_ekosystemy.py"><b>Pobierz</b></a>
</div>

<h1 class="headers">Projekty:</h1>

<div class="button_container">

<a href="gra_w_zycie.html" target="_blank" rel="noopener noreferrer" class="button-link"><b>Gra w życie</b></a>
</div>

</main>

<script>
  const nav = document.querySelector('.nav1');
  const toggleButton = document.getElementById('toggleNav');

  function isMobile() {
    return window.innerWidth <= 768;
  }

  function checkMobileMenu() {
    if (isMobile()) {
      toggleButton.classList.remove('hidden');
      nav.classList.add('hidden');
    } else {
      toggleButton.classList.add('hidden');
      nav.classList.remove('hidden');
      nav.classList.remove('active');
    }
  }

  toggleButton.addEventListener('click', () => {
    nav.classList.toggle('active');
  });

  window.addEventListener('resize', checkMobileMenu);
  window.addEventListener('load', checkMobileMenu);
</script>

<footer style="text-align:center; padding:20px; margin-top:50px; color:gray;">
  © 2025 Vladyslav Dovhopiatyi. Wszelkie prawa zastrzeżone.
</footer>


</body>
</html>
