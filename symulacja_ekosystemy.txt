<!DOCTYPE html>
<html lang="pl">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="UTF-8">
<meta name="keywords" content="projekty, Python, Java, Gra w Å¼ycie, ekosystem, symulacje, programowanie, Vladyslav Dovhopiatyi">
<meta name="description" content="Symulacja ekosystemu w Pythonie â€” automatyczna aplikacja inspirowana grÄ… w Å¼ycie Conwaya, z organizmami o rÃ³Å¼nych typach (roÅ›liny, roÅ›linoÅ¼ercy, miÄ™soÅ¼ercy, wszystkoÅ¼ercy), ktÃ³re poruszajÄ… siÄ™, jedzÄ…, rozmnaÅ¼ajÄ… i umierajÄ…. Projekt zawiera wizualizacjÄ™ za pomocÄ… emoji i wykresy zmian populacji."> 
<meta name="author" content="Vladyslav Dovhopiatyi">
<title>Symulacja ekosystemu &mdash; gra w Pythonie bez udziaÅ‚u gracza</title>
<!-- <link rel="icon" type="image/svg+xml" href="favicon.svg"> -->
<link rel="icon" type="image/png" href="favicon.png">

<style>

* {box-sizing: border-box;} 

@keyframes colorchange {
0% {background-color: #ffffff;}
20% {background-color: #ccffcc;}
40% {background-color: #ffffff;}
60% {background-color: #ccffff;}
80% {background-color: #ffffff;}
100% {background-color: #ccccff;}
}

body {
margin-top: 80px;
animation: colorchange 60s infinite;
}

header {
position: fixed;
top:0; left:0; right:0;
z-index: 1000;
background-color: #0040ff;
padding: 10px;
display: flex;
justify-content: space-between;
max-height: 100px;
}

.szukaj-container {	
max-width: 250px;
margin: 10px auto
}

#google_search {
width: 200%;
padding: 10px 10px 10px 15px;
border: 1px solid black;
border-radius: 25px;
}

.autocomplete-item {
background-color: white;
border: 1px solid #d4d4d4;
cursor: pointer;
padding: 10px;
width: 200%;
}

.autocomplete-item:hover {
background-color: #e9e9e9;
}

.autocomplete-active {
background-color: #d4d4d4;
}

.nav1 {
position: fixed;
top: 70px;
left: 0;
width: 20%;
height: 100%; 
background-color: rgb(0, 162, 255);
padding: 20px;
}

.nav1 a {
display: block;
padding: 10px 20px;
text-decoration: none;
color: black;
}

.nav1 a:hover {
background-color: hsl(280, 100%, 70%)
}

.headers {
text-align:center;
margin-left: 25%;
width: 75%;
}

p {
text-align:center;
margin-left: 25%;
font-size: 120%;
line-height: 1.6;
}

@keyframes bounce {
0%, 100% { transform: translateY(0); }
50% { transform: translateY(10px); }
}

.style_code {
background-color: #f2f2f2;
border-radius: 10px;
font-size: 14px;
line-height: 1.5;
border: 2px solid rgb(128, 128, 128);
margin-left: 25%;
padding: 10px;
display: block;
overflow-x: auto;
max-height: 250px;
overflow-y: hidden;
}

.style_code.expanded {
max-height: 700px;
overflow-y: auto;
}

.button_container {
text-align: center;
margin-left: 25%;
width: 75%;
}

a.button-link {
text-align:center;
border-radius: 25px;
background-color:#cc66ff;
color:white;
padding: 15px 25px;
text-decoration: none;
display: inline-block;
margin: 5px;
}
a.button-link:hover {
background-color: #d32f2f;
}

.square_container {
display: flex;
flex-wrap: wrap;
justify-content: center;
margin-left: 25%;
width: 75%;
gap: 20px;
margin-top: 30px;
}

.square {
background-color:#ffffff;
border-radius: 15px;
padding: 20px;
width: 100%;
box-shadow: 10px 10px 1px #ccccff;
transition: transform 0.5s;
display: flex;
align-items: center;
min-height: 200px; 
}

.square p {
text-align: left;
margin: 0;
line-height: 2;
}

@media (max-width: 768px) {

.szukaj-container {
max-width: 100%;
width: 250px;
margin: 10px auto;
}

#google_search {
width: 100%;
padding: 10px 15px;
border: 1px solid black;
border-radius: 25px;
box-sizing: border-box;
}

.nav1 {
width: 250px;
left: -260px;
transition: left 0.3s ease;
padding-top: 60px;
}

.nav1.active {
left: 0;
}

#toggleNav {
position: fixed;
top: 82px;
left: 0px;
z-index: 1100;
font-size: 20px;
background: #669999;
color: white;
border: 3px solid black;
padding: 8px 12px;
cursor: pointer;
display: block;
}

#toggleNav.hidden {
display: none;
}

header {
display: flex;
flex-wrap: wrap; 
align-items: center;
justify-content: space-between;
}

h1, p, .square_container, .button_container {
margin-left: 0;
width: 100%;
padding: 10px;
}

.headers {
text-align: center;
padding: 10px;
width: 100%;
}

p {
text-align: center;
padding: 10px;
font-size: 120%;
width: 100%;
}

.square {
padding: 10px;
font-size: 100%;
}

.style_code {
font-size: 12px;
padding: 10px;
margin: 0;
width: 100%;
}

.headers, p, .button_container {
padding: 10px;
margin-left: 0;
width: 100%;
}
  
.square, .headers, .style_code {
max-width: 900px;
margin: auto;
}

.square_container {
display: flex;
flex-wrap: wrap;
justify-content: center;
padding: 10px;
gap: 20px;
margin-left: 0;
width: 100%;
}
.square {
width: 100%;
}
}
</style>

</head>
<body>

<button id="toggleNav" class="hidden" aria-label="Menu">â˜°</button>

<header>

<a href="omnie.html">
<img src="favi.jpg" alt="Logo strony" width="50" height="50">
</a>

<div class="szukaj-container">
<input id="google_search" type="text" placeholder="Wyszukiwarka projektÃ³w" autocomplete="off" oninput="obsÅ‚uga_wyszukiwarki()" aria-label="Wyszukiwarka projektÃ³w">
<div id="autocomplete-list" class="autocomplete-items" style="max-width: 250px; margin-top: 5px;"></div>
</div>

</header>

<nav class="nav1">
<a href="index.html">Python: co to?</a>
<a href="gra_w_zycie.html">Gra w Å¼ycie</a>
<a href="symulacja_ekosystemy.html">Symulacja ekosystemy</a>
<a href="omnie.html">O mnie</a>

</nav>

<main>

<script src="wyszukiwarka_script.js"></script>

<h1 class="headers">Symulacja ekosystemu</h1>

<div class="square_container">
<div class="square">

<p>Symulacja ekosystemu to zautomatyzowana gra, ktÃ³ra modeluje interakcje miÄ™dzy rÃ³Å¼nymi typami organizmÃ³w: roÅ›linami, roÅ›linoÅ¼ercami, miÄ™soÅ¼ercami i wszystkoÅ¼ercami. Projekt czÄ™Å›ciowo opiera siÄ™ na wczeÅ›niejszej pracy &mdash; â€Gra w Å¼ycieâ€ &mdash; i wykorzystuje niektÃ³re metody, funkcje oraz zaimportowane moduÅ‚y. Do wizualizacji symulacji uÅ¼ywana jest biblioteka <b>PyQt5</b>, a do tworzenia wykresÃ³w i diagramÃ³w &mdash; <b>matplotlib.</b></p>

</div>
</div>

<div class="square_container">
<div class="square">

<p>Gra dziaÅ‚a caÅ‚kowicie autonomicznie i nie wymaga interwencji uÅ¼ytkownika. KaÅ¼dy typ organizmu posiada wÅ‚asne zasady istnienia: rozmnaÅ¼ania, starzenia siÄ™, odÅ¼ywiania oraz Å›mierci. W przypadku caÅ‚kowitego wyginiÄ™cia danego typu organizmu, zostaje on automatycznie odtworzony w celu zachowania biorÃ³Å¼norodnoÅ›ci i rÃ³wnowagi ekosystemu.</p>

</div>
</div>

<p style="color:#cc0000;"><strong>&#128187; PeÅ‚ny kod znajdziesz na koÅ„cu tej strony. &#128187; </strong></p>

<p style="padding-top:0px; font-size: 250%; color:#cc0000; animation: bounce 1.5s infinite;"><b>&#x2B07; &#x2B07; &#x2B07;</b></p>

<div class="button_container">
<a href="#projekt_kon_sym" class="button-link"><b>Symulacja ekosystemy</b></a>
</div>
<br>
<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Imports</h2>


<pre><code class="style_code">
import sys
import random
import csv
import matplotlib.pyplot as plt
from PyQt5.QtWidgets import QApplication, QWidget, QGridLayout, QLabel
from PyQt5.QtCore import Qt, QTimer
</code></pre>

<div class="square_container">
<div class="square">

<p><b style="color:#e65c00">import</b> <b>sys</b> &mdash; moduÅ‚ umoÅ¼liwiajÄ…cy pracÄ™ z funkcjami systemowymi.<br>

<b style="color:#e65c00">import</b> <b>random</b> &mdash; moduÅ‚ do generowania losowych liczb i losowego wyboru elementÃ³w.<br>

<b style="color:#e65c00">import</b> <b>csv</b> &mdash; Importuje standardowy moduÅ‚ Pythona <b>csv</b>, ktÃ³ry umoÅ¼liwia odczyt i zapis danych w formacie czÄ™sto uÅ¼ywanym do przechowywania tabelarycznych danych.<br>

<b style="color:#e65c00">import</b> <b>matplotlib.pyplot as plt</b> &mdash; Importuje moduÅ‚ <b>pyplot</b> z biblioteki <b>matplotlib</b> i nadaje mu alias <b>plt</b>. UmoÅ¼liwia tworzenie wykresÃ³w, diagramÃ³w i wizualizacji danych.

</div>
</div>

<div class="square_container">
<div class="square">

<p><b style="color:#e65c00">from</b> <b>PyQt5.QtWidgets</b> <b style="color:#e65c00">import</b> <b>QApplication, QWidget, QGridLayout, QLabel</b> &mdash; Ten wiersz importuje klasy z biblioteki PyQt5, ktÃ³re sÅ‚uÅ¼Ä… do tworzenia graficznego interfejsu uÅ¼ytkownika: <b>QApplication</b> zarzÄ…dza aplikacjÄ…, <b>QWidget</b> reprezentuje gÅ‚Ã³wne okno lub komponenty, <b>QGridLayout</b> umoÅ¼liwia siatkowe rozmieszczanie elementÃ³w, a <b>QLabel</b> sÅ‚uÅ¼y do wyÅ›wietlania tekstu lub obrazÃ³w.<br>

<b style="color:#e65c00">from</b> <b>PyQt5.QtCore</b> <b style="color:#e65c00">import</b> <b>Qt, QTimer</b> &mdash; importuje klasy z PyQt5 do tworzenia GUI: okna, ukÅ‚adu, grafiki i timerÃ³w.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Rozmiar okna</h2>

<pre><code class="style_code">
rozmiar_okna = 30 #Ustawiamy rozmiar okna (bÄ™dzie uÅ¼yty dalej w kodzie)
</code></pre>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Organizm &mdash; gÅ‚Ã³wny klas(rodzic)</h2>

<pre><code class="style_code">
class Organizm:
    def __init__(self):
        self.wiek = 0
        self.energia = 0

    def symbol(self):
        return 'â¬œ'

    def generacja(self, x, y, Plansza):
        self.wiek += 1

    def znalezc_sasiadow(self, x, y, Plansza):
        sasiedzi = []
        for delta_x in range(-1, 2):
            for delta_y in range(-1, 2):
                if (delta_x == 0 and delta_y == 0):
                    continue
                nowy_x = x + delta_x
                nowy_y = y + delta_y
                if 0 &lt;= nowy_x &lt; rozmiar_okna and 0 &lt;= nowy_y &lt; rozmiar_okna:
                    sasiedzi.append((nowy_x, nowy_y, Plansza[nowy_x][nowy_y]))
        random.shuffle(sasiedzi)
        return sasiedzi
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Ten kluczowy klas rodzicielski jest bazÄ… dla innych klas, takich jak Pustka, Roslina, RoÅ›linoÅ¼erca, MiÄ™soÅ¼erca oraz WszystkoÅ¼erca. Takie podejÅ›cie zapewnia wygodne i elastyczne dziedziczenie wÅ‚aÅ›ciwoÅ›ci i metod. PoczÄ…tkowo kaÅ¼dy organizm ma wiek i energiÄ™ ustawione na zero, co umoÅ¼liwia pÃ³Åºniejsze Å‚atwe modyfikacje tych wartoÅ›ci. <br>Metoda <code><b>symbol(self)</b></code> zwraca symbol biaÅ‚ego kwadratu (&#11036;), ktÃ³ry reprezentuje niezajÄ™tÄ… przestrzeÅ„ na planszy.<br>Metoda <code><b>generacja(self, x, y, Plansza)</b></code> odpowiada za inkrementacjÄ™ wieku organizmu o jeden w kaÅ¼dej generacji symulacji.<br>Metoda <code><b>znalezc_sasiadow(self, x, y, Plansza)</b></code> przeszukuje sÄ…siednie pola wokÃ³Å‚ pozycji (x, y), szukajÄ…c sÄ…siadÃ³w w promieniu 1 pola w kaÅ¼dym kierunku. Znalezieni sÄ…siedzi sÄ… losowo tasowani, co umoÅ¼liwia symulowanie losowego ruchu organizmÃ³w lub ucieczki od nich.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa Pustka &mdash; reprezentuje puste pole na planszy</h2>

<pre><code class="style_code">
class Pustka(Organizm):
    def symbol(self):
        return "â¬œ"
</code></pre>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Pustka</b></code> dziedziczy po klasie <code><b>Organizm</b></code> i reprezentuje niezajÄ™tÄ… przestrzeÅ„ na planszy ekosystemu. Jej gÅ‚Ã³wnym zadaniem jest zwracanie odpowiedniego symbolu â€” pustego biaÅ‚ego kwadratu (&#11036;) &mdash; co umoÅ¼liwia Å‚atwe wizualne rozrÃ³Å¼nienie wolnych miejsc od tych zajÄ™tych przez inne organizmy.<br>Klasa ta nie zawiera dodatkowej logiki ani metod, poniewaÅ¼ nie bierze udziaÅ‚u w procesach takich jak rozmnaÅ¼anie, ruch czy zdobywanie energii. SÅ‚uÅ¼y jedynie jako "tÅ‚o" lub "przestrzeÅ„" w symulacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa RoÅ›lin</h2>

<pre><code class="style_code">
class Roslina(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 1
    def symbol(self):
        return "ğŸ¥•"

    def generacja(self, x, y, Plansza):
        self.wiek += 1
        if self.energia &lt; 10:
            self.energia += 1

        liczba_roslin = 0
        for wiersz in Plansza:
            for organizm in wiersz:
                if type(organizm) &#61;&#61; Roslina:
                    liczba_roslin +&#61; 1

        max_roslin = (rozmiar_okna * rozmiar_okna) // 2

        if self.wiek >= 4 and liczba_roslin &lt; max_roslin:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) &#61;&#61; Pustka:
                    Plansza[nowy_x][nowy_y] = Roslina()
                    break
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Roslina</b></code> dziedziczy po <code><b>Organizm</b></code> i reprezentuje roÅ›liny w ekosystemie. W konstruktorze nadawana jest poczÄ…tkowa energia <code>1</code>, co odzwierciedla zdolnoÅ›Ä‡ roÅ›liny do powolnego gromadzenia energii.<br> Metoda <code><b>symbol()</b></code> zwraca ikonÄ™ ğŸ¥•, ktÃ³ra sÅ‚uÅ¼y do wizualnego przedstawienia roÅ›liny na planszy.<br>W metodzie <code><b>generacja()</b></code> kaÅ¼da roÅ›lina starzeje siÄ™ (wiek +1) oraz powoli zwiÄ™ksza swojÄ… energiÄ™, maksymalnie do 10. JeÅ›li osiÄ…gnie wiek co najmniej 4 i caÅ‚kowita liczba roÅ›lin w ekosystemie jest mniejsza niÅ¼ poÅ‚owa pÃ³l planszy, roÅ›lina prÃ³buje rozmnoÅ¼yÄ‡ siÄ™ na sÄ…siednie wolne pole. DziÄ™ki temu systemowi roÅ›liny mogÄ… siÄ™ rozprzestrzeniaÄ‡, ale ich liczba pozostaje pod kontrolÄ…, co zapobiega zdominowaniu caÅ‚ej planszy.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa RoÅ›linoÅ¼erca</h2>

<pre><code class="style_code">
class Roslinozerca(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 8
    def symbol(self):
        return "ğŸ‡"

    def generacja(self, x, y, Plansza):
        self.wiek += 1
        if self.energia &lt;&#61; 0:           #nie umiera kiedy niema energii, jeÅ›li nie ma energii i pojawi siÄ™ roÅ›lina, moÅ¼na jÄ… zjeÅ›Ä‡
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) &#61;&#61; Roslina:
                    self.energia += 2
                    Plansza[nowy_x][nowy_y] = Pustka()
                    break
            if self.wiek > 15:
                Plansza[x][y] = Pustka()
                return
        self.energia -= 1
        ruch = False

        for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
            if type(sasiad) == Roslina:
                self.energia += 2
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break

        if not ruch:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Pustka:
                    self.energia -= 1
                    Plansza[nowy_x][nowy_y] = self
                    Plansza[x][y] = Pustka()
                    break
        if self.wiek >= 4 and self.energia >= 4:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Roslinozerca and sasiad.wiek >= 4 and sasiad.energia >= 4:
                    for pustka_x, pustka_y, pustka in self.znalezc_sasiadow(x, y, Plansza):
                        if type(pustka) == Pustka:
                            Plansza[pustka_x][pustka_y] = Roslinozerca()
                            break
                    break
        if self.wiek > 15:
            Plansza[x][y] = Pustka() #umiera, gdy osiÄ…ga wiek 15 lat

</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Roslinozerca</b></code> reprezentuje zwierzÄ™ roÅ›linoÅ¼erne w ekosystemie, np. krÃ³lika ğŸ‡. Dziedziczy po klasie <code><b>Organizm</b></code> i zaczyna z energiÄ… rÃ³wnÄ… 8.<br>Organizm ten staje siÄ™ coraz starszy i z kaÅ¼dÄ… generacjÄ… traci energiÄ™. Gdy energia spada do zera, roÅ›linoÅ¼erca nadal prÃ³buje przetrwaÄ‡ â€” jeÅ›li w sÄ…siedztwie znajdzie roÅ›linÄ™, moÅ¼e jÄ… zjeÅ›Ä‡ i odzyskaÄ‡ energiÄ™. JeÅ›li jednak jest juÅ¼ stary (powyÅ¼ej 15 cykli), umiera.<br>W przypadku znalezienia roÅ›liny, przemieszcza siÄ™ w jej miejsce, zwiÄ™kszajÄ…c energiÄ™. Gdy nie znajdzie jedzenia, prÃ³buje przesunÄ…Ä‡ siÄ™ na puste pole, tracÄ…c dodatkowÄ… energiÄ™.<br>JeÅ›li roÅ›linoÅ¼erca osiÄ…gnÄ…Å‚ wiek co najmniej 4 cykle i posiada wystarczajÄ…cÄ… energiÄ™, moÅ¼e siÄ™ rozmnaÅ¼aÄ‡, jeÅ›li w pobliÅ¼u znajdzie siÄ™ inny roÅ›linoÅ¼erca speÅ‚niajÄ…cy te same warunki oraz dostÄ™pne jest puste pole.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa MiÄ™soÅ¼erca</h2>

<pre><code class="style_code">
class Miesozerca(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 12
    def symbol(self):
        return "ğŸº"

    def generacja(self, x, y, Plansza):
        self.wiek += 1

        if self.energia &lt;&#61; 0:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) &#61;&#61; Roslinozerca:
                    self.energia += 9
                    Plansza[nowy_x][nowy_y] = Pustka()
                    break
            if self.wiek > 25:
                Plansza[x][y] = Pustka()
                return
        self.energia -= 2
        ruch = False

        for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
            if type(sasiad) == Roslinozerca:
                self.energia += 9
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break

        if not ruch:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Pustka:
                    self.energia -= 2
                    Plansza[nowy_x][nowy_y] = self
                    Plansza[x][y] = Pustka()
                    break
        if self.wiek >= 5 and self.energia >= 10:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Miesozerca and sasiad.wiek >= 5 and sasiad.energia >= 10:
                    for pustka_x, pustka_y, pustka in self.znalezc_sasiadow(x, y, Plansza):
                        if type(pustka) == Pustka:
                            Plansza[pustka_x][pustka_y] = Miesozerca()
                            break
        if self.wiek > 25:
            Plansza[x][y] = Pustka()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Miesozerca</b></code> reprezentuje drapieÅ¼nika w ekosystemie, na przykÅ‚ad wilka ğŸº. Dziedziczy po klasie <code><b>Organizm</b></code> i startuje z energiÄ… 12 jednostek.<br>W kaÅ¼dej generacji zwiÄ™ksza siÄ™ wiek organizmu, a energia spada o 2 jednostki. JeÅ›li energia spadnie do zera, miÄ™soÅ¼erca jeszcze prÃ³buje zjeÅ›Ä‡ pobliskiego roÅ›linoÅ¼ercÄ™, aby przetrwaÄ‡. Gdy nie znajdzie poÅ¼ywienia i osiÄ…gnie wiek powyÅ¼ej 25, umiera.<br>MiÄ™soÅ¼erca aktywnie szuka w otoczeniu roÅ›linoÅ¼ercÃ³w, aby je zjeÅ›Ä‡ i zdobyÄ‡ energiÄ™. JeÅ›li nie znajdzie ofiary, prÃ³buje przemieÅ›ciÄ‡ siÄ™ na wolne pole, ale traci przy tym kolejne 2 jednostki energii.<br>RozmnaÅ¼anie jest moÅ¼liwe, gdy organizm osiÄ…gnie wiek co najmniej 5 i ma energiÄ™ co najmniej 10. Wtedy, jeÅ›li w pobliÅ¼u znajduje siÄ™ inny miÄ™soÅ¼erca speÅ‚niajÄ…cy te warunki oraz dostÄ™pne jest puste pole, tworzony jest nowy osobnik.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Klasa WszystkoÅ¼erca</h2>

<pre><code class="style_code">
class Wszystkozerca(Organizm):
    def __init__(self):
        Organizm.__init__(self)
        self.energia = 10
    def symbol(self):
        return "ğŸ»"

    def generacja(self, x, y, Plansza):
        self.wiek += 1

        if self.energia &lt;&#61; 0:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Roslina:
                    self.energia += 3
                    Plansza[nowy_x][nowy_y] = Pustka()
                elif type(sasiad) &#61;&#61; Miesozerca:
                    self.energia += 7
                    Plansza[nowy_x][nowy_y] = Pustka()
                    break
            if self.wiek > 30:
                Plansza[x][y] = Pustka()
                return
        self.energia -= 1
        ruch = False

        for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
            if type(sasiad) == Roslina:
                self.energia += 3
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break
            elif type(sasiad) == Miesozerca:
                self.energia += 7
                Plansza[nowy_x][nowy_y] = self
                Plansza[x][y] = Pustka()
                ruch = True
                break

        if not ruch:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Pustka:
                    self.energia -= 1
                    Plansza[nowy_x][nowy_y] = self
                    Plansza[x][y] = Pustka()
                    break
        if self.wiek >= 5 and self.energia >= 8:
            for nowy_x, nowy_y, sasiad in self.znalezc_sasiadow(x, y, Plansza):
                if type(sasiad) == Wszystkozerca and sasiad.wiek >= 5 and sasiad.energia >= 8:
                    for pustka_x, pustka_y, pustka in self.znalezc_sasiadow(x, y, Plansza):
                        if type(pustka) == Pustka:
                            Plansza[pustka_x][pustka_y] = Wszystkozerca()
                            break
        if self.wiek > 30:
            Plansza[x][y] = Pustka()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Klasa <code><b>Wszystkozerca</b></code> reprezentuje wszystkoÅ¼ernego organizma, np. niedÅºwiedzia ğŸ». Jest bardziej elastyczny niÅ¼ inne organizmy â€” moÅ¼e jeÅ›Ä‡ zarÃ³wno roÅ›liny (ğŸ¥•), jak i miÄ™soÅ¼ercÃ³w (ğŸº).<br>W kaÅ¼dej generacji wiek zwiÄ™ksza siÄ™ o 1, a energia spada o 1. JeÅ›li energia spadnie do zera, organizm prÃ³buje znaleÅºÄ‡ poÅ¼ywienie â€” zjadajÄ…c roÅ›linÄ™ (+3 energii) lub miÄ™soÅ¼ercÄ™ (+7 energii). Gdy nie przeÅ¼yje i przekroczy wiek 30, umiera.<br>WszystkoÅ¼erca szuka poÅ¼ywienia w sÄ…siedztwie, zaczynajÄ…c od roÅ›lin i miÄ™soÅ¼ercÃ³w. JeÅ›li znajdzie jedzenie, przemieszcza siÄ™ tam i regeneruje energiÄ™. W przeciwnym razie prÃ³buje przemieÅ›ciÄ‡ siÄ™ na wolne pole, tracÄ…c kolejnÄ… jednostkÄ™ energii.<br>RozmnaÅ¼a siÄ™, gdy osiÄ…ga wiek â‰¥5 i energiÄ™ â‰¥8, pod warunkiem, Å¼e w sÄ…siedztwie znajduje siÄ™ inny dojrzaÅ‚y wszystkoÅ¼erca. Wtedy, jeÅ›li dostÄ™pne jest pole Pustki, powstaje nowy osobnik.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers"><mark>FabrykaKomorek</mark></h2>

<pre><code class="style_code">
class FabrykaKomorek:
    @staticmethod
    def utworz_komorke(type):
        if type == "Roslina":
            return  Roslina()
        elif type == "Roslinozerca":
            return  Roslinozerca()
        elif type == "Miesozerca":
            return Miesozerca()
        elif type == "Wszystkozerca":
            return Wszystkozerca()
        else:
            return Pustka()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><code><b>FabrykaKomorek</b></code> to klasa pomocnicza, ktÃ³ra peÅ‚ni rolÄ™ <b>fabryki statycznej</b> â€” wzorca projektowego sÅ‚uÅ¼Ä…cego do tworzenia obiektÃ³w rÃ³Å¼nych klas potomnych bez potrzeby rÄ™cznego wywoÅ‚ywania kaÅ¼dego konstruktora.<br>GÅ‚Ã³wna metoda <code><b>utworz_komorke(type)</b></code> dziaÅ‚a jako <b>statyczna metoda</b> (oznaczona jako <code><b>@staticmethod</b></code>), co oznacza, Å¼e moÅ¼na jej uÅ¼ywaÄ‡ bez tworzenia instancji klasy <code><b>FabrykaKomorek</b></code>.<br>Metoda przyjmuje tekstowy parametr <code><b>type</b></code> i â€” w zaleÅ¼noÅ›ci od jego wartoÅ›ci â€” tworzy i zwraca odpowiedni obiekt.<br>DziÄ™ki temu kod w innych czÄ™Å›ciach programu moÅ¼e dynamicznie tworzyÄ‡ organizmy na podstawie np. danych wejÅ›ciowych, bez potrzeby znajomoÅ›ci szczegÃ³Å‚Ã³w konstruktora danego organizmu. To zwiÄ™ksza modularnoÅ›Ä‡ i upraszcza zarzÄ…dzanie typami komÃ³rek w symulacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Obserwator</h2>

<pre><code class="style_code">
class Obserwator:
    def aktualizuj(self, plansza):
        pass
</code></pre>

<div class="square_container">
<div class="square">

<p><code><b>Obserwator</b></code> to abstrakcyjna (bazowa) klasa, ktÃ³ra peÅ‚ni rolÄ™ interfejsu w architekturze opartej na wzorcu <b>Obserwator</b><br>Zawiera metodÄ™ <code><b>aktualizuj(self, plansza)</b></code>, ktÃ³ra na tym etapie nie wykonuje Å¼adnych dziaÅ‚aÅ„ (<code>pass</code>), ale zostaÅ‚a zdefiniowana, aby mogÅ‚a byÄ‡ nadpisywana przez klasy potomne.<br>Klasy dziedziczÄ…ce po <code><b>Obserwator</b></code> implementujÄ… wÅ‚asnÄ… wersjÄ™ metody <code><b>aktualizuj()</b></code>, ktÃ³ra pozwala reagowaÄ‡ na zmiany stanu planszy, np. odÅ›wieÅ¼ajÄ…c widok graficzny, zapisujÄ…c dane lub analizujÄ…c ekosystem.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">GUI</h2>

<p style=" background-color: #ffff00;">GUI &mdash; to Graphical User Interface, czyli po polsku &mdash; graficzny interfejs uÅ¼ytkownika</p>

<pre><code class="style_code">
class GUIWidok(Obserwator):
    def __init__(self):
        self.app = QApplication(sys.argv)
        self.window = QWidget()
        self.layout = QGridLayout(self.window)
        self.generacja_label = QLabel("Generacja: 0", self.window)
        self.generacja_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.generacja_label, 0, 0, 1, rozmiar_okna)
        self.labels = [[QLabel("â¬œ") for _ in range(rozmiar_okna)] for _ in range(rozmiar_okna)]
        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                self.layout.addWidget(self.labels[y][x], y + 1, x)
        self.window.setLayout(self.layout)
        self.window.setWindowTitle("Ekosystem")
        self.window.show()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<table style="width: 100%; border-collapse: collapse;" border="3" cellpadding="10">
<caption style="font-size: 150%; margin-bottom: 10px;"><b>GUIWidok</b></caption>
<tr style="background-color: #ff0000; color: white;">
  <th>Kod</th>
  <th>Za co odpowiada</th>
</tr>
<tr>
  <td><code>self.app = QApplication(sys.argv)</code></td>
  <td>Tworzy gÅ‚Ã³wnÄ… aplikacjÄ™ PyQt5</td>
</tr>
<tr>
  <td><code>self.window = QWidget()</code></td>
  <td>Tworzy gÅ‚Ã³wne okno aplikacji</td>
</tr>
<tr>
  <td><code>self.layout = QGridLayout(self.window)</code></td>
  <td>UkÅ‚ad siatki â€” rozkÅ‚ada elementy w siatce (komÃ³rki planszy)</td>
</tr>
<tr>
  <td><code>self.generacja_label = QLabel("Generacja: 0", self.window)</code></td>
  <td>WyÅ›wietla numer aktualnej generacji</td>
</tr>
<tr>
  <td><code>self.generacja_label.setAlignment(Qt.AlignCenter)</code></td>
  <td>WyÅ›rodkowuje tekst z numerem generacji</td>
</tr>
<tr>
  <td><code>self.layout.addWidget(self.generacja_label, 0, 0, 1, rozmiar_okna)</code></td>
  <td>Umieszcza etykietÄ™ generacji nad caÅ‚Ä… planszÄ…</td>
</tr>
<tr>
  <td><code>self.labels = [[QLabel("â¬œ") for _ in range(rozmiar_okna)] for _ in range(rozmiar_okna)]</code></td>
  <td>Tworzy dwuwymiarowÄ… listÄ™ etykiet reprezentujÄ…cych komÃ³rki planszy</td>
</tr>
<tr>
  <td><code>self.layout.addWidget(self.labels[y][x], y + 1, x)</code></td>
  <td>Dodaje etykiety komÃ³rek do siatki poniÅ¼ej etykiety generacji</td>
</tr>
<tr>
  <td><code>self.window.setLayout(self.layout)</code></td>
  <td>Ustawia layout jako gÅ‚Ã³wny ukÅ‚ad okna</td>
</tr>
<tr>
  <td><code>self.window.setWindowTitle("Ekosystem")</code></td>
  <td>Ustawia tytuÅ‚ okna</td>
</tr>
<tr>
  <td><code>self.window.show()</code></td>
  <td>WyÅ›wietla okno aplikacji</td>
</tr>
</table>

</div>
</div>

<h2 class="headers">Aktualizacja GUI</h2>

<pre><code class="style_code">
    def aktualizuj(self, plansza, numer_generacji = 0):
        self.generacja_label.setText(f"Generacja: {numer_generacji}")
        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                self.labels[y][x].setText(plansza[y][x].symbol())
</code></pre>

<div class="square_container">
<div class="square">

<p>Metoda <code><b>aktualizuj</b></code> odpowiada za odÅ›wieÅ¼enie interfejsu graficznego (GUI) po kaÅ¼dej generacji symulacji. Najpierw aktualizuje etykietÄ™ z numerem pokolenia (<code><b>generacja_label</b></code>), wyÅ›wietlajÄ…c aktualnÄ… liczbÄ™ generacji. NastÄ™pnie przechodzi przez wszystkie komÃ³rki planszy w dwÃ³ch pÄ™tlach i pobiera z kaÅ¼dej z nich obiekt organizmu. Dla kaÅ¼dego organizmu wywoÅ‚ywana jest metoda <code><b>symbol()</b></code>, ktÃ³ra zwraca graficzny znak (np. ğŸ¥•, ğŸ‡, ğŸº), 
a nastÄ™pnie ten znak jest wyÅ›wietlany w odpowiednim polu siatki GUI (<code><b>QLabel</b></code>). W ten sposÃ³b stan planszy w modelu jest na bieÅ¼Ä…co odwzorowywany wizualnie w aplikacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Inicjalizacja klasy Symulacja</h2>

<pre><code class="style_code">
class Symulacja:
    def __init__(self, plansza, widok):
        self.plansza = plansza
        self.widok = widok
        self.generacja = 0
        self.startowe_ilosci = {
            "Roslina": 1,
            "Roslinozerca": 20,
            "Miesozerca": 10,
            "Wszystkozerca": 3
        }

        self.csv_file_path = 'dane.csv'
        with open(self.csv_file_path, 'w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(["Generacja", "Roslina", "Roslinozerca", "Miesozerca", "Wszystkozerca"])

        self.timer = None
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p>Konstruktor klasy <code><b>Symulacja</b></code> odpowiada za przygotowanie wszystkich niezbÄ™dnych elementÃ³w do rozpoczÄ™cia symulacji ekosystemu.<br><code><b>self.plansza</b></code> &mdash; odniesienie do dwuwymiarowej tablicy zawierajÄ…cej organizmy w Å›wiecie symulacji. <code><b>self.widok</b></code> &mdash; obiekt GUI (np. <code>GUIWidok</code>), odpowiedzialny za graficzne przedstawienie planszy. <code><b>self.generacja</b></code> &mdash; licznik pokoleÅ„ (etapÃ³w symulacji), poczÄ…tkowo ustawiony na zero. <code><b>self.startowe_ilosci</b></code> &mdash; sÅ‚ownik definiujÄ…cy ile osobnikÃ³w kaÅ¼dego typu ma byÄ‡ dodawane, jeÅ›li ktÃ³ryÅ› z nich zniknie caÅ‚kowicie z planszy (np. 20 roÅ›linoÅ¼ercÃ³w, 10 miÄ™soÅ¼ercÃ³w itd.). <code><b>self.csv_file_path</b></code> &mdash; Å›cieÅ¼ka do pliku CSV, gdzie bÄ™dÄ… zapisywane dane statystyczne kaÅ¼dej generacji (liczebnoÅ›Ä‡ kaÅ¼dego typu organizmu). NastÄ™pnie tworzony jest nowy plik <code><b>dane.csv</b></code> i zapisywany jest nagÅ‚Ã³wek kolumn, aby mÃ³c pÃ³Åºniej Å‚atwo dodawaÄ‡ dane i generowaÄ‡ wykresy. Zmienna <code><b>self.timer</b></code> jest domyÅ›lnie ustawiona na <code>None</code> i bÄ™dzie uÅ¼ywana do kontrolowania, kiedy zatrzymaÄ‡ symulacjÄ™ (np. po 300 generacjach).</p>

</div>
</div>

<h2 class="headers">Ustawianie timera</h2>

<pre><code class="style_code">
def czas_trwania(self, timer):
    self.timer = timer
    #Prosta metoda pomocnicza przypisujÄ…ca zewnÄ™trzny timer do obiektu klasy, ktÃ³ry moÅ¼e byÄ‡ pÃ³Åºniej uÅ¼yty do zatrzymania animacji po 300 generacjach.
</code></pre>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Aktualizacja symulacji</h2>

<pre><code class="style_code">
    def aktualizuj(self):
        if self.generacja >= 300:
            if self.timer:
                self.timer.stop()
            print("Symulacja zakoÅ„czona po 300 generacjach")
            return

        kierunek = [(x, y) for y in range(rozmiar_okna) for x in range(rozmiar_okna)]
        random.shuffle(kierunek)
        for x, y in kierunek:
            self.plansza[y][x].generacja(y, x, self.plansza)
        self.generacja += 1
        self.widok.aktualizuj(self.plansza, self.generacja)
        self.dodaj_brakujace_klasy()

        ilosc_roslin = 0
        ilosc_roslinozercow = 0
        ilosc_miesozercow = 0
        ilosc_wszystkozercow = 0

        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                organizm = self.plansza[y][x]
                if type(organizm) == Roslina:
                    ilosc_roslin += 1
                if type(organizm) == Roslinozerca:
                    ilosc_roslinozercow += 1
                if type(organizm) == Miesozerca:
                    ilosc_miesozercow += 1
                if type(organizm) == Wszystkozerca:
                    ilosc_wszystkozercow += 1
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Kontrola zakoÅ„czenia symulacji:</b> JeÅ›li liczba generacji osiÄ…gnÄ™Å‚a 300, zatrzymujemy timer i wyÅ›wietlamy komunikat o zakoÅ„czeniu symulacji. <b>Losowa kolejnoÅ›Ä‡ przetwarzania planszy:</b> Tworzymy listÄ™ wszystkich wspÃ³Å‚rzÄ™dnych planszy, tasujemy jÄ…, aby symulacja byÅ‚a bardziej realistyczna i nieprzewidywalna. <b>WywoÅ‚anie metody generacja dla kaÅ¼dego organizmu:</b> Dla kaÅ¼dej pozycji na planszy wywoÅ‚ujemy metodÄ™ <code><b>generacja</b></code>, ktÃ³ra odpowiada za aktualizacjÄ™ stanu organizmu. <b>ZwiÄ™kszenie numeru generacji i aktualizacja widoku:</b> Po przetworzeniu caÅ‚ej planszy zwiÄ™kszamy licznik generacji i aktualizujemy GUI za pomocÄ… metody <code><b>aktualizuj</b></code> widoku. <b>Dodanie brakujÄ…cych klas organizmÃ³w:</b> JeÅ›li jakieÅ› typy organizmÃ³w zniknÄ™Å‚y z planszy, metoda <code><b>dodaj_brakujace_klasy</b></code> wprowadzi ich nowe instancje na wolne pola. <b>Zliczanie organizmÃ³w na planszy:</b> Iterujemy po caÅ‚ej planszy i zliczamy ile jest instancji kaÅ¼dego typu organizmu (<b><code>Roslina</code>, <code>Roslinozerca</code>, <code>Miesozerca</code>, <code>Wszystkozerca</code></b>).</p>

</div>
</div>

<h2 class="headers">plik CSV</h2>

<pre><code class="style_code">
        with open(self.csv_file_path, 'a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([self.generacja, ilosc_roslin, ilosc_roslinozercow, ilosc_miesozercow, ilosc_wszystkozercow])

        generacje = []
        rosliny = []
        roslinozercy = []
        miesozercy = []
        wszystkozercy = []

        with open(self.csv_file_path, mode= 'r') as file:
            czytacz = csv.DictReader(file)
            for wiersz in czytacz:
                generacje.append(int(wiersz['Generacja']))
                rosliny.append(int(wiersz['Roslina']))
                roslinozercy.append(int(wiersz['Roslinozerca']))
                miesozercy.append(int(wiersz['Miesozerca']))
                wszystkozercy.append(int(wiersz['Wszystkozerca']))
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Zapis danych do pliku CSV:</b> Otwieramy plik CSV w trybie dopisywania ('a') i zapisujemy aktualne wartoÅ›ci populacji oraz numer generacji w nowym wierszu. <b>Inicjalizacja list do przechowywania danych z pliku:</b> Tworzymy puste listy, ktÃ³re bÄ™dÄ… przechowywaÄ‡ kolejno numer generacji oraz liczby poszczegÃ³lnych organizmÃ³w. <b>Odczyt danych z pliku CSV:</b> Otwieramy plik w trybie odczytu i uÅ¼ywamy <code>csv.DictReader</code> do wygodnego czytania wierszy jako sÅ‚ownikÃ³w. <b>WypeÅ‚nianie list danymi:</b> Dla kaÅ¼dego wiersza z pliku wyciÄ…gamy wartoÅ›ci dla kluczy: 'Generacja', 'Roslina', 'Roslinozerca', 'Miesozerca' oraz 'Wszystkozerca' i zamieniamy je na liczby caÅ‚kowite, dodajÄ…c do odpowiednich list.</p>

</div>
</div>

<h2 class="headers">Wykresy</h2>

<pre><code class="style_code">
        #wykres_liniowy:
        plt.plot(generacje, rosliny, label='Rosliny')
        plt.plot(generacje, roslinozercy, label='Roslinozercy')
        plt.plot(generacje, miesozercy, label='Miesozercy')
        plt.plot(generacje, wszystkozercy, label='Wszystkozercy')

        plt.title('Wykres liniowy populacji organizmÃ³w')
        plt.xlabel('Generacja')
        plt.ylabel('Liczba organizmow')
        plt.legend()
        plt.tight_layout()
        plt.savefig('wykres_liniowy.png', dpi=300)
        plt.close()

        #wykres_koÅ‚owy:
        wartosci = [ilosc_roslin, ilosc_roslinozercow, ilosc_miesozercow, ilosc_wszystkozercow]
        labels = ['Rosliny', 'Roslinozercy', 'Miesozercy', 'Wszystkozercy']

        plt.figure(figsize=(8, 6))
        plt.pie(wartosci, labels=labels, autopct='%1.1f%%', startangle=140)
        plt.axis('equal')
        plt.title('Wykres koÅ‚owy populacji organizmÃ³w')
        plt.tight_layout()
        plt.savefig('wykres_kolowy.png', dpi=300)
        plt.close()
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Wykres liniowy:</b> Tworzymy wykres liniowy przedstawiajÄ…cy zmiany liczebnoÅ›ci populacji rÃ³Å¼nych organizmÃ³w w kolejnych generacjach. KaÅ¼da linia reprezentuje jednÄ… klasÄ™ organizmÃ³w (Rosliny, Roslinozercy, Miesozercy, Wszystkozercy). Dodajemy tytuÅ‚, opisy osi (Generacja i Liczba organizmÃ³w), legendÄ™ oraz optymalizujemy ukÅ‚ad elementÃ³w, aby dobrze siÄ™ wyÅ›wietlaÅ‚y. Zapisujemy wykres jako plik PNG o wysokiej rozdzielczoÅ›ci (300 dpi), a nastÄ™pnie zamykamy wykres, by zwolniÄ‡ zasoby.<br><b>Wykres koÅ‚owy:</b> Przygotowujemy listÄ™ wartoÅ›ci reprezentujÄ…cych aktualnÄ… liczebnoÅ›Ä‡ populacji kaÅ¼dej klasy organizmÃ³w oraz odpowiadajÄ…ce im etykiety. Ustawiamy rozmiar figury, tworzymy wykres koÅ‚owy z procentowym udziaÅ‚em kaÅ¼dej populacji, ustawiamy rÃ³wnÄ… skalÄ™ osi, tytuÅ‚ i optymalny ukÅ‚ad elementÃ³w. Zapisujemy wykres koÅ‚owy jako plik PNG i zamykamy go, aby zwolniÄ‡ pamiÄ™Ä‡.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">UzupeÅ‚nianie brakujÄ…cych klas organizmÃ³w</h2>

<pre><code class="style_code">
    def dodaj_brakujace_klasy(self):
        klasy = {"Roslina": False, "Roslinozerca": False, "Miesozerca": False, "Wszystkozerca": False}

        for y in range(rozmiar_okna):
            for x in range(rozmiar_okna):
                objekt = self.plansza[y][x]
                if type(objekt) == Roslina:
                    klasy["Roslina"] = True
                elif type(objekt) == Roslinozerca:
                    klasy["Roslinozerca"] = True
                elif type(objekt) == Miesozerca:
                    klasy["Miesozerca"] = True
                elif type(objekt) == Wszystkozerca:
                    klasy["Wszystkozerca"] = True

        for klasa, obecny in klasy.items():
            if not obecny:
                wolne_pola = [(x, y) for y in range(rozmiar_okna) for x in range(rozmiar_okna)
                          if type(self.plansza[y][x]) == Pustka]
                ilosc_do_dodania = self.startowe_ilosci[klasa]
                for _ in range(ilosc_do_dodania):
                    if wolne_pola:
                        x, y = random.choice(wolne_pola)
                        wolne_pola.remove((x, y))
                        self.plansza[y][x] = FabrykaKomorek.utworz_komorke(klasa)
</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Sprawdzanie obecnoÅ›ci klas:</b> Na poczÄ…tku metoda tworzy sÅ‚ownik z nazwami klas organizmÃ³w, oznaczajÄ…c kaÅ¼dÄ… jako nieobecnÄ… (<code><b>False</b></code>). NastÄ™pnie przeglÄ…da caÅ‚e pole gry (<code><b>plansza</b></code>) i sprawdza, czy ktÃ³ryÅ› z typÃ³w juÅ¼ siÄ™ na nim znajduje â€” jeÅ›li tak, zmienia jego status na <code><b>True</b></code>.<br><b>Dodawanie brakujÄ…cych organizmÃ³w:</b> Dla kaÅ¼dej nieobecnej klasy tworzeÅ„ metoda wyszukuje wszystkie wolne pola (czyli te zawierajÄ…ce obiekt typu <code><b>Pustka</b></code>). NastÄ™pnie na podstawie wstÄ™pnie zdefiniowanej liczby startowej (<code><b>startowe_ilosci</b></code>) losowo wybiera miejsca i umieszcza tam nowe obiekty danego typu przy pomocy metody <code><b>FabrykaKomorek.utworz_komorke</b></code>. DziÄ™ki temu na planszy zawsze znajduje siÄ™ przynajmniej jeden przedstawiciel kaÅ¼dej klasy organizmÃ³w.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Inicjalizacja planszy i losowanie pÃ³l</h2>

<pre><code class="style_code">
plansza = [[Pustka() for _ in range(rozmiar_okna)] for _ in range(rozmiar_okna)]
wolne_pola = [(x, y) for y in range(rozmiar_okna) for x in range(rozmiar_okna)]
random.shuffle(wolne_pola)
</code></pre>

<div class="square_container">
<div class="square">

<p> Na poczÄ…tku tworzymy dwuwymiarowÄ… listÄ™ <code>plansza</code>, ktÃ³ra reprezentuje pole gry. KaÅ¼de pole poczÄ…tkowo zawiera obiekt typu <code><b>Pustka()</b></code>, co oznacza, Å¼e jest puste i gotowe do zapeÅ‚nienia organizmami.<br> NastÄ™pnie generujemy listÄ™ wszystkich moÅ¼liwych wspÃ³Å‚rzÄ™dnych (x, y) dla caÅ‚ej planszy, ktÃ³re poczÄ…tkowo sÄ… wszystkie wolne. DziÄ™ki temu mamy peÅ‚nÄ… kontrolÄ™ nad tym, gdzie moÅ¼na umieszczaÄ‡ nowe organizmy.<br> Za pomocÄ… <code><b>random.shuffle()</b></code> mieszamy kolejnoÅ›Ä‡ wspÃ³Å‚rzÄ™dnych w liÅ›cie <code>wolne_pola</code>. Pozwala to losowo przydzielaÄ‡ miejsca dla organizmÃ³w w dalszych etapach inicjalizacji, co sprawia, Å¼e rozkÅ‚ad startowy jest za kaÅ¼dym razem inny i nieprzewidywalny.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Dodawanie organizmÃ³w na planszÄ™</h2>

<pre><code class="style_code">
def dodaj_obekty(type, liczba):
    for _ in range(liczba):
        if wolne_pola:
            x, y = random.choice(wolne_pola)
            wolne_pola.remove((x, y))
            plansza[y][x] = FabrykaKomorek.utworz_komorke(type)

dodaj_obekty("Roslina", 1)
dodaj_obekty("Roslinozerca",20)
dodaj_obekty("Miesozerca", 10)
dodaj_obekty("Wszystkozerca", 3)

</code></pre>

<div class="button_container">
<div class="toggle_button">
<button onclick="toggleCode(this)" class="button-link" style="background-color: #66ccff; color: black; border: none; border-radius: 15px; padding: 15px 25px; font-weight: bold; cursor: pointer;">PokaÅ¼ wiÄ™cej</button>
</div>
</div>

<div class="square_container">
<div class="square">

<p><b>Funkcja dodaj_obekty:</b> Definiujemy funkcjÄ™, ktÃ³ra umoÅ¼liwia dodawanie okreÅ›lonej liczby organizmÃ³w danego typu na losowe, wolne pola planszy. Dla kaÅ¼dego obiektu losujemy wspÃ³Å‚rzÄ™dne z listy dostÄ™pnych pÃ³l <code>wolne_pola</code>, a nastÄ™pnie usuwamy to pole z listy, by uniknÄ…Ä‡ powtÃ³rzeÅ„. Obiekt tworzony jest za pomocÄ… fabryki komÃ³rek <code><mark>FabrykaKomorek.utworz_komorke(type)</mark></code>, co zapewnia elastycznoÅ›Ä‡ w tworzeniu rÃ³Å¼nych typÃ³w organizmÃ³w.<br> Po zdefiniowaniu funkcji wywoÅ‚ujemy jÄ…, aby dodaÄ‡ rÃ³Å¼ne klasy organizmÃ³w. DziÄ™ki temu plansza zostaje zainicjalizowana startowÄ… populacjÄ… zgodnie z zaÅ‚oÅ¼eniami symulacji.</p>

</div>
</div>

<hr style="border: none; height: 10px; background-color: #cc00cc; margin: 20px 0;">

<h2 class="headers">Inicjalizacja i uruchomienie symulacji graficznej</h2>

<pre><code class="style_code">
widok = GUIWidok()
symulacja = Symulacja(plansza, widok)
timer = QTimer()
symulacja.czas_trwania(timer)
timer.timeout.connect(lambda: symulacja.aktualizuj())
symulacja.aktualizuj()
timer.start(300)
widok.window.setGeometry(100, 100, 500, 500)
sys.exit(widok.app.exec_())
</code></pre>

<div class="square_container">
<div class="square">

<table style="width: 100%; border-collapse: collapse;" border="3" cellpadding="10">
<tr style="background-color: #ff0000; color: white;">
<th>Kod</th>
<th>Opis</th>
</tr>
<tr>
<td><code>widok = GUIWidok()</code></td>
<td>Tworzy instancjÄ™ interfejsu graficznego, ktÃ³ra odpowiada za wizualne przedstawienie planszy i jej aktualizacji.</td>
</tr>
<tr>
<td><code>symulacja = Symulacja(plansza, widok)</code></td>
<td>Inicjalizuje logikÄ™ symulacji, przekazujÄ…c planszÄ™ oraz obiekt widoku GUI, aby mogÅ‚y wspÃ³Å‚pracowaÄ‡.</td>
</tr>
<tr>
<td><code>timer = QTimer()</code></td>
<td>Tworzy obiekt timera Qt, ktÃ³ry umoÅ¼liwia cykliczne wykonywanie akcji w okreÅ›lonych odstÄ™pach czasu.</td>
</tr>
<tr>
<td><code>symulacja.czas_trwania(timer)</code></td>
<td>Ustawia zaleÅ¼noÅ›Ä‡ pomiÄ™dzy timerem a symulacjÄ… â€” pozwala symulacji kontrolowaÄ‡ czas jej dziaÅ‚ania (np. dÅ‚ugoÅ›Ä‡ trwania).</td>
</tr>
<tr>
<td><code>timer.timeout.connect(lambda: symulacja.aktualizuj())</code></td>
<td>ÅÄ…czy sygnaÅ‚ zakoÅ„czenia odliczania timera z metodÄ… aktualizacji symulacji, co pozwala na automatyczne odÅ›wieÅ¼anie stanu gry.</td>
</tr>
<tr>
<td><code>symulacja.aktualizuj()</code></td>
<td>WywoÅ‚uje natychmiastowe odÅ›wieÅ¼enie stanu planszy, tak aby pierwsze dane byÅ‚y widoczne przed uruchomieniem timera.</td>
</tr>
<tr>
<td><code>timer.start(300)</code></td>
<td>Uruchamia timer z interwaÅ‚em 300 milisekund, co oznacza aktualizacjÄ™ symulacji co 0,3 sekundy.</td>
</tr>
<tr>
<td><code>widok.window.setGeometry(100, 100, 500, 500)</code></td>
<td>Ustawia pozycjÄ™ oraz rozmiar gÅ‚Ã³wnego okna aplikacji GUI (500x500 pikseli, pozycja: x=100, y=100).</td>
</tr>
<tr>
<td><code>sys.exit(widok.app.exec_())</code></td>
<td>Uruchamia gÅ‚Ã³wnÄ… pÄ™tlÄ™ zdarzeÅ„ aplikacji PyQt i zamyka jÄ… poprawnie po zakoÅ„czeniu dziaÅ‚ania programu.</td>
</tr>
</table>

</div>
</div>

<script>
function toggleCode(button) {
const code = button.closest('.button_container').previousElementSibling.querySelector('.style_code');
code.classList.toggle('expanded');
button.textContent = code.classList.contains('expanded') ? 'Ukryj' : 'PokaÅ¼ wiÄ™cej';
}
</script>

<h2 class="headers" id="projekt_kon_sym"><b>PeÅ‚ny kod "Symulacja ekosystemy"</b></h2>

<div class="button_container">
<a href="symulacja_ekosystemy.py" target="_blank" rel="noopener noreferrer" class="button-link" download="symulacja_ekosystemy.py"><b>Pobierz</b></a>
</div>

<h1 class="headers">Projekty:</h1>

<div class="button_container">

<a href="gra_w_zycie.html" target="_blank" rel="noopener noreferrer" class="button-link"><b>Gra w Å¼ycie</b></a>
</div>

</main>

<script>
  const nav = document.querySelector('.nav1');
  const toggleButton = document.getElementById('toggleNav');

  function isMobile() {
    return window.innerWidth <= 768;
  }

  function checkMobileMenu() {
    if (isMobile()) {
      toggleButton.classList.remove('hidden');
      nav.classList.add('hidden');
    } else {
      toggleButton.classList.add('hidden');
      nav.classList.remove('hidden');
      nav.classList.remove('active');
    }
  }

  toggleButton.addEventListener('click', () => {
    nav.classList.toggle('active');
  });

  window.addEventListener('resize', checkMobileMenu);
  window.addEventListener('load', checkMobileMenu);
</script>

<footer style="text-align:center; padding:20px; margin-top:50px; color:gray;">
  Â© 2025 Vladyslav Dovhopiatyi. Wszelkie prawa zastrzeÅ¼one.
</footer>


</body>
</html>
